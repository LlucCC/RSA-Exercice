#definicions de funcions úitils
#-------------------------------

#Funció per factoritzar un nombre n que només tingui 2 factors primers 
def factoritzar(n):
    p = 0
    i = 2
    
    if (n%2 == 0): return (2, n//2)

    i += 1
    while (i*i <= n and p == 0):
        if n%i == 0:
            p = i 
        i += 2
        
    q = n//p
    return (p,q)

#Algorisme d'euclides estés
def euclidesEstes(a, b): 

    # Cas base: gcd(0, B) = ax + by ==> gcd(0,B) = 0*a + 1*b = b
    if (a == 0): 
        x = 0
        y = 1
        return (b,x,y) 
  
    # Crida recursiva
    (gcd,x1,y1) = euclidesEstes(b % a, a) 

    x = y1 - (b // a) * x1 
    y = x1 
  
    return (gcd, x, y)
  
#Retorna la inversa modular de A en módul N
def modInversa(A, N): 
  
    #Calculem gcd(A,B) = ax + by, hem d'obtenir x i y.
    #Com que b = N --> b*y = 0 mod N, llavors per a que es compleixi (ax + by = 1 mod N), ax = 1 mod N ==> X ES LA INVERSA MODULAR DE A EN MODUL N
    #Sabem que e i N son coprimers així que podem utilitzar lo anterior
    (g,x,_) = euclidesEstes(A, N) 

    #Per si no son coprimers(No hauria de passar)
    if (g != 1): 
        print("No hi ha inversa") 
        return -1
  
    #Inversa real
    else: 

        inver = x % N 
        return inver

#retorna a^b mod n 
def exp_modular(a, b, N):
    if (b == 0):
        return 1
    
    if (b == 1): 
        return a%N
    
    else:
        b2 = b//2
        res = exp_modular(a,b2,N)
        res = (res*res)%N
        if (b%2 != 0): res = (res*a)%N
    
        return res

#Algorisme de desencriptació
def desenctiptar(msg, L, k, N):
    #dividim el missatge en trossos
    C = [msg[i:i + L] for i in range (0,len(msg), L)]
    
    #Calculem Pi = Ci^k mod n
    n_trossos = len(C)
    P = [str(i) for i in range(0, n_trossos)]
    for i in range (0, n_trossos):
        aux = int(C[i])
        tmp = exp_modular(aux,k,N)
        #Introduim el número calculat amb el format adequat (L - 1 xifres, s'afegeixen 0's si no hi han suficients xifres)
        P[i] = "{num:0{width}}".format(num = tmp, width = L - 1)
    
    #Concatenem els trossos per obtenir P
    msg_desencriptat = ""
    for i in range(0, n_trossos):
        msg_desencriptat = msg_desencriptat + P[i]
    
    #Mirem si els 3 primers nombres formen un nombre major a 254
    if (int(msg_desencriptat[0:3]) > 254):
        msg_desencriptat = '0' + msg_desencriptat
    
    #Tallem el missatge en trossos de 3
    msg_ascii = [msg_desencriptat[i:i + 3] for i in range (0,len(msg_desencriptat), 3)]
    
    #Transformem el ASCII a caràcters
    msg_final = ""
    for i in range (0, len(msg_ascii)):
        msg_final = msg_final + chr(int(msg_ascii[i]))

    return msg_final


#Aqui comença el codi
#---------------------

#Podriem llegir directament el missatge del arxiu, però com que tampoc és tan llarg he escollit copiar-lo
msg = "070572532910646530120810805650468122649598010363146828500858601108002449958701117458138109263984733002429067910054348819700660854051005031573770795843441907690168562050013284490755094470604131582984043837702571235196458800157683821085179259310276723472704634583345021468212441201726496712670991201009033862520730288629109040095834049121029451280088070003747689373028922449630856337248205211584559018547370201227680824401443242056039724987870262517962409967371800096987455531256125176804224759699124568130670116465870709391887749009582612701188389279005832547663101271391290936719794811016412653006685291830415709022208702958228095978720550462698105300362543454037631023920374240702705197454177064592999830837729715311293342504092732797180409245430810891150931101271391290078247344504547687432094928825320593093405501112775402098710366120924992877708282813445082597683901220609473409500090707048876374720641879789306342499691094928825320618043213412839047027005839477210379820863010860755195102831469180133266697702003120691077289842021115743953605937912423037751225841144861063002239860724126100901950004804356606746571585114272102250964183112806901652388124429800990813044708610888696563060314336150713952531002606634964108798233921144861063002239860724049121029450352067856504134031157126100901950004804356612859772546117896176310270874766412945312372043620355350007089195712373783074083529017371292376523212207010450049931026660720304622912581959756028826006880276634707511611250902039735252950565545288010630348419119496592990620062345805207323323126874156221117458138102327925332007066327300564117538710590208287112289636500897402862010057169427016372433480049336819100524467624009577531820148562298606358857190111589819211035588302802980729670084846268040326877004303200130955033912712521235936897407532805642043585445451185133139605619720491103512049530767778019107181135441098710366120924992877708282813445040888209760085355765001079543809089781293340019636357202675591522032303223531136941941811340956433066613653340652237723308097889950066429659510818857461303164723204068166505100784461041808097889950000380729030177975864009389376588063314337110947201158607499030150051266760500772379394204816121692101161562060646530120810805650468089652404940294781282708519004185097507990390789319056200698470973102831469180435745172509263802423065705326750912627997003038029363002449958701117458138103995369193030950482971095753263008097889950000380729031151679583705050489575086177743920520612695310708220192048420079671235936897405211584559000380729031151679583705050489575052168316050163378885511888978195035726583881107147310104449277141069755627270681195844708097889950123635025630195469599109834401213101967960541257643351202102445316039113152080458665610610859982675018654819270892201907908274353462052778260840074621631000532409484065344012310724880951107719145307111362248700813044708604979316785043585445450662815543307063202895124934889110919740999510593250715076626165360711451855408007449258111852039430562717623412415899428071256930090234777715208564301450042512476900939836065206068022293127011440060673166264303158930819010546200211020761475207940610781025817142530972538935003577379626005755473400186130065112485699467039341162390540704158406052542681039724987870363146828500858601108128685076670227296574611836687562045818168440459565136808594863769117946150721172116152205817958285036408834050697613698205805754946012035254650052982256408660771289111362248700759220028509083111231081531503980225263916201112775402002766857600758077771804333931247063383755010812427675304437704522081752779450053158235307055879887032671626450662815543300280334215034170414690785081288708534740773017773017181057758181602247204137037540189740220415555405714192639083547350340964646397302541784162038750835270127784158605124775060067564477851261608724904498703673101161562060646530120810805650468122649598010363146828500858601108106753877860262128151310170460894033912712520633448763310556838801044020283630340930435009649587662051386518111178168269407164128582029586891750090542935409392516230048513798600861258847608097889950001387316940020401512607934993071"
n =  13011817607
e = 3127313

#Factoritzem n
(p,q) = factoritzar(n)


print("Factors de " + str(n) + ":")
print("p: " + str(p))
print("q: " + str(q))
print("p*q = " + str(q*p))

#Calculem k com el invers modular de e en modul phi(n) = (p - 1) * (q - 1)
phi = (p - 1)*(q - 1)
k = modInversa(e, phi)

print("\n")
print("Clau privada k = " + str(k))
print("k*e mod n = "+ str((k*e)%n))


#Desencriptem missatge
msg_desencriptat = desenctiptar(msg, 11, k, n)
print("\nMissatge desencriptat: ")
print(msg_desencriptat)

nv = 103651 * 103457
ev = 103001

#aqui entra el codi pel PGP
print("----------PGP----------")
print(nv)
print(ev)

PGP = "Lluc Clavera Comas"
P = ""

#Transformem el missatge a ASCII
for c in PGP:
    P = P + str(ord(c))

#Tallem el missatge en parts
P2 = ["{num:0{width}}".format(num = int(P[i:i + 10]), width = 10) for i in range (0,len(P), 10)]

#Calculem Pi^e mod n
C = [i for i in range(0, len(P2))]
for i in range(0,len(P2)):
    C[i] = "{num:0{width}}".format(num = exp_modular(int(P2[i]),ev,nv) , width = 11)

#Concatenem totes les parts
C2 = ""
for s in C:
    C2 = C2 + s

print(C2)
